# Lời mở đầu

Con Redline Stealer này gần đây có vẻ nổi, trên các blog chuyên report malware cũng có rất nhiều, nhưng đôi khi các mẫu mã độc khác nhau và nhiều bài còn sơ sài nên nay mình sẽ phân tích thử em nó.
Hash: **4250602036e16dedef56f32955aa4611628e3a87fa53bf2e23e30ddd8b4bd8fd**

# Stage 1
Em nó là file PE 32 bit, nhòm qua IDA xem thế nào.
![](1.PNG)

Một số nhận xét:
	* File không bị pack.
	* `scanf` có tham số là 0, 0, 0, 0. Mà scanf được nằm cứng trong file, nếu đi sâu vào các hàm con của wWinMain ta thấy các hàm con vô dụng và không có ý nghĩa lắm. Như vậy chủ yếu là để làm rối AV thôi.

Phân tích hàm được gọi cuối cùng của wWinMain.
![](2.PNG)

Thấy rằng các tham số của API toàn là 0, thôi biết là làm rối thì lướt xuống xem thì thấy nó gọi hàm `sub_404627()`.
![](4.PNG)

Nó gọi hàm từ `dword_4DA824`, ok đáng ngờ phết. Đặt breakpoint rồi debug.
*Chú ý: Trong lúc debug có bị ngoại lệ là do thằng LocalFlags(0), vá IAT của nó để IAT trỏ tới ret của hàm là ok*
![](5.PNG)

# Stage 2
![](6.PNG)

Okie ta nhảy tới một đoạn shellcode. Ấn F8 tới chết nhé :))
![](7.PNG)

`fs:30h` thì lại quen quá rồi, nó định load PEB rồi ldr của PEB để duyệt qua toàn bộ các dll load cùng với file. F8 tiếp thì thấy có `kernel32.dll`, `LoadLibraryA()` và `GetProcAddress()`.
![](10.PNG)
![](11.PNG)
![](13.PNG)

Có được cặp đôi `LoadLibraryA()` và `GetProcAddress()`, nó tìm tới địa chỉ của một số hàm sau:
![](15.PNG)

Nhìn đôi `CreateToolhelp32Snapshot()` và `Module32First()`, khả năng định duyệt các dll được load lần 2. F8 tiếp thì thấy nó có gọi `VirtualAlloc()` và nhả về `0x2440000`. Kiểu này lại có Stage 3 rồi.
![](17.PNG)

F8 nhiều lần để qua cái đoạn code giải mã và ghi và `0x2440000`, ta view vùng nhớ đó bằng `Process Hacker` thì đoán được đây vẫn là một dạng shellcode.
![](18.PNG)

# Stage 3
F8 thì ta nhảy tới vùng nhớ đó:
![](19.PNG)

Đi tiếp ta lại thấy `fs:30h`.
![](20.PNG)

Thôi các bạn tự làm tiếp nhé, chạy tới đây là cũng tìm được `GetProcAddress()` và `LoadLibraryA()`.
![](24.PNG)

Nó sẽ tìm tiếp địa chỉ một số hàm như `VirtualAlloc` và `VirtualProtect`, :(. Mình đoán lại thêm cái Stage nữa, khổ quá mà. Okie trace tiếp đến đoạn nó gọi `VirtualAlloc()` thì nó nhả về `0x2380000`
![](26.PNG)

Khô máu qua cái đoạn decrypt payload lên cái địa chỉ `0x2380000` rồi view nó thì vui gần chết, cuối cùng cũng thấy chữ `MZ`:
![](27.PNG)

*Chú ý: Đoạn này nhỡ ấn F9 nên phải debug lại, địa chỉ của vùng nhớ trên Stage 2 là 0x22F0000 nhé*
Mình sẽ đi tiếp để tìm kiếm một đoạn nhảy để tìm OEP, nhưng khi đi tiếp mình thấy nó gọi `VirtualProctect()` lên `0x400000` (chính là địa chỉ base của mã độc) với tham số `PAGE_EXECUTE_READWRITE`.
![](28.PNG)

Kiểu này là chắc định ghi đè lên vùng nhớ của file rồi, Stage 4 là rõ. Đi tiếp thấy nó gọi `VirtualFree()` lên `0x2380000` tức là vùng nhớ này đã xong nhiệm vụ của mình là ghi payload mới lên `0x400000`. Debug tiếp đến đoạn này:
![](32.PNG)

`eax = 0x40CD2F`, nó sẽ nhảy lại về section `.text`. Vậy entry point mới ở offset 0xCD2F, đến đây là dump `0x400000` được rồi.
![](33.PNG)
![](34.PNG)

# Stage 4
Bình thường mọi người dump bằng Scylla nhưng không hiểu sao fix dump rồi vẫn không chạy được nên mình nghĩ ra cách đơn giản hơn nhiều. Đó là dump bình thường bằng `Process Hacker` rồi fix là `Raw Address` trong section header để nó bằng với `Virtual Address` tương ứng.
![](35.PNG)

Đây là hình ảnh của em nó sau dump:
![](36.PNG)

Debug thấy nó call `_getenv("Cor_Enable_Profiling")`, đây là kiểu anti debug .NET, nhưng đây là file PE viết bằng C mà :).
![](37.PNG)

Lại còn có cả chuỗi `mscorjit.dll`, rõ ràng có gì mờ ám liên quan tới .NET.
![](38.PNG)

Thật ra nó sử dụng kỹ thuật CLR Hosting. Mọi người có thể tham khảo blog sau.
![](2023-02-10-00-05-06.png)

Nói qua thì nó là kỹ thuật cho phép gọi .NET Assemblies trong code C, hay chuyên môn hơn là gọi managed code bằng unmanaged code. Đây là code cơ bản của CLR Hosting:
![](2023-02-10-00-07-14.png)

Nhưng chỉ khác bước cuối nó không gọi Assembly từ đường dẫn file mà bằng con trỏ tới vùng nhớ chưa Assemblies. Mà ta lại thấy có lời gọi tới hàm `FindResourceA`, `LoadResource`,... là cũng đoán là Assembly ở trong `.rsrc` rồi, cơ mà có vẻ bị mã hoá. Tiếp tục debug tới đây nhé:
![](42.PNG)

Đó các bạn sẽ thấy thằng `edi` đang trỏ tới vùng nhớ bắt đầu bằng chuỗi `MZ`, đây chính là Assembly .NET. Vùng nhớ này trong heap nên sử dụng IDAPython để dump. Trước tiên là dump 0x400 bytes để lấy header, đọc header để xem kích thước file rồi dump lại lần 2. Vứt file dump được vào `dnSpy` và `CFF Explorer`.
![](45.PNG)
![](50.PNG)

# Stage 5
![](49.PNG)

Từ các hình trên và hiểu biết về CLR Hosting ta biết nó sẽ gọi phương thức `___`. Phương thức này đang làm gì đó với Resource và tạo một Assembly mới từ Resource. Dump cái Resource đó ra ta có Stage 6 (chắc tới đây hacker lười lắm rồi nên chả mã hoá gì luôn :D)
![](50.PNG)

# Stage 6
![](51.PNG)

Đây là Stage 6, vâng như bạn thấy có rất nhiều phương thức nhưng hàm Main chả gọi gì cả, phương thức `WriteLine` thì rỗng. Đến lúc này mình bí lắm rồi nên mới nhìn trộm report của `Bitdefender` thì nó có bảo là constructor `Program()` được gọi trước và sẽ giải mã byte code trong lúc chạy và `JIT` nó sẽ dịch cái byte code đã được giải mã. Cơ mà dump Assembly đã giải mã như thế nào.

Lên search google tìm ra được tool đỉnh vch, chỉ cần chạy file mã độc gốc, nó sẽ tự xác định được các Assembly .NET trong tiến trình, rồi chọn dump thì nó sẽ nhả toàn bộ Assembly tìm được.
![](2023-02-10-00-20-48.png)

Cái `Bludger` là file cuối cùng
![](2023-02-10-00-24-29.png)
![](2023-02-10-00-27-38.png)

Cảm ơn đã theo dõi.


